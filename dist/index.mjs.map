{"version":3,"sources":["../src/index.ts"],"names":["WaitlyClient","config","entry","endpoint","error","response","email","controller","method","body","url","requestId","abortController","timeoutId","options","lastError","attempt","ms","resolve","createWaitlyClient","index_default"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * Waitlist SDK - Client JavaScript/TypeScript to manage waitlists\n * @version 1.0.0\n */\n\nexport interface WaitlyConfig {\n  waitlistId: string;\n  apiKey: string;\n  apiUrl?: string;\n  timeout?: number;\n  retryAttempts?: number;\n  headers?: Record<string, string>;\n}\n\nexport interface WaitlyEntry {\n  email: string;\n  name?: string;\n  referralCode?: string;\n  metadata?: Record<string, any>;\n  source?: string;\n  locale?: string;\n}\n\nexport interface WaitlyEntryResponse {\n  success: boolean;\n  entryId: string;\n  position: number;\n  referralLink: string;\n  referralCode: string;\n  estimatedWaitTime?: string;\n  createdAt: string;\n}\n\nexport interface WaitlyStats {\n  totalEntries: number;\n  todayEntries: number;\n  weekEntries: number;\n  monthEntries: number;\n  averageWaitTime?: string;\n  conversionRate?: number;\n  topReferrers?: Array<{\n    referralCode: string;\n    count: number;\n  }>;\n}\n\nexport interface WaitlyError {\n  code: string;\n  message: string;\n  details?: any;\n  statusCode?: number;\n}\n\nexport class WaitlyClient {\n  private config: Required<WaitlyConfig>;\n  private abortControllers: Map<string, AbortController> = new Map();\n\n  constructor(config: WaitlyConfig) {\n    if (!config.waitlistId) {\n      throw new Error(\"waitlistId is required\");\n    }\n    if (!config.apiKey) {\n      throw new Error(\"apiKey is required\");\n    }\n\n    this.config = {\n      waitlistId: config.waitlistId,\n      apiKey: config.apiKey,\n      apiUrl: config.apiUrl || \"https://api.waitlist.com\",\n      timeout: config.timeout || 10000,\n      retryAttempts: config.retryAttempts || 3,\n      headers: config.headers || {},\n    };\n  }\n\n  /**\n   * Create a new entry in the waitlist\n   * @param entry - Entry data\n   * @returns Promise with the entry details\n   */\n  async createWaitlyEntry(entry: WaitlyEntry): Promise<WaitlyEntryResponse> {\n    if (!entry.email) {\n      throw new Error(\"Email is required\");\n    }\n    if (!this.isValidEmail(entry.email)) {\n      throw new Error(\"Invalid email format\");\n    }\n\n    const endpoint = `/api/waitlists/${this.config.waitlistId}/entries`;\n\n    try {\n      const response = await this.request<WaitlyEntryResponse>(\n        \"POST\",\n        endpoint,\n        {\n          email: entry.email.toLowerCase().trim(),\n          name: entry.name?.trim(),\n          referralCode: entry.referralCode,\n          metadata: entry.metadata,\n          source: entry.source || \"sdk\",\n        }\n      );\n\n      return response;\n    } catch (error) {\n      throw this.handleError(error);\n    }\n  }\n\n  /**\n   * Get the number of entries in the waitlist\n   * @param options - Filtering options (optional)\n   * @returns Promise with the statistics\n   */\n  async getWaitlyEntriesCount(): Promise<number | WaitlyStats> {\n    const endpoint = `/api/waitlists/${this.config.waitlistId}/count`;\n\n    try {\n      const response = await this.request<WaitlyStats | { count: number }>(\n        \"GET\",\n        endpoint\n      );\n\n      return \"totalEntries\" in response\n        ? (response as WaitlyStats).totalEntries\n        : (response as { count: number }).count;\n    } catch (error) {\n      throw this.handleError(error);\n    }\n  }\n\n  /**\n   * Check if an email is already registered\n   * @param email - Email to check\n   * @returns Promise<boolean>\n   */\n  async checkEmailExists(email: string): Promise<boolean> {\n    if (!this.isValidEmail(email)) {\n      throw new Error(\"Invalid email format\");\n    }\n\n    const endpoint = `/api/waitlists/${this.config.waitlistId}/check`;\n\n    try {\n      const response = await this.request<{ exists: boolean }>(\n        \"POST\",\n        endpoint,\n        { email: email.toLowerCase().trim() }\n      );\n      return response.exists;\n    } catch (error) {\n      throw this.handleError(error);\n    }\n  }\n\n  /**\n   * Cancel all requests\n   */\n  cancelAllRequests(): void {\n    this.abortControllers.forEach((controller) => controller.abort());\n    this.abortControllers.clear();\n  }\n\n  // Méthodes privées\n\n  private async request<T>(\n    method: string,\n    endpoint: string,\n    body?: any\n  ): Promise<T> {\n    const url = `${this.config.apiUrl}${endpoint}`;\n    const requestId = `${method}-${endpoint}-${Date.now()}`;\n\n    // Créer un AbortController pour cette requête\n    const abortController = new AbortController();\n    this.abortControllers.set(requestId, abortController);\n\n    // Timeout\n    const timeoutId = setTimeout(() => {\n      abortController.abort();\n    }, this.config.timeout);\n\n    const options: RequestInit = {\n      method,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-API-Key\": this.config.apiKey,\n        \"X-SDK-Version\": \"1.0.0\",\n        \"X-Waitlist-ID\": this.config.waitlistId,\n        ...this.config.headers,\n      },\n      signal: abortController.signal,\n    };\n\n    if (body && method !== \"GET\") {\n      options.body = JSON.stringify(body);\n    }\n\n    let lastError: any;\n\n    // Retry logic\n    for (let attempt = 0; attempt < this.config.retryAttempts; attempt++) {\n      try {\n        const response = await fetch(url, options);\n\n        clearTimeout(timeoutId);\n        this.abortControllers.delete(requestId);\n\n        if (!response.ok) {\n          const error = await response.json().catch(() => ({\n            message: `HTTP ${response.status}: ${response.statusText}`,\n          }));\n\n          // Ne pas retry pour les erreurs client (4xx)\n          if (response.status >= 400 && response.status < 500) {\n            throw { statusCode: response.status, ...error };\n          }\n\n          lastError = { statusCode: response.status, ...error };\n\n          // Retry avec backoff exponentiel pour les erreurs serveur\n          if (attempt < this.config.retryAttempts - 1) {\n            await this.delay(Math.pow(2, attempt) * 1000);\n            continue;\n          }\n        }\n\n        const data = await response.json();\n        return data as T;\n      } catch (error: any) {\n        clearTimeout(timeoutId);\n        this.abortControllers.delete(requestId);\n\n        if (error.name === \"AbortError\") {\n          throw new Error(\"Request timeout\");\n        }\n\n        lastError = error;\n\n        // Retry avec backoff pour les erreurs réseau\n        if (attempt < this.config.retryAttempts - 1 && !error.statusCode) {\n          await this.delay(Math.pow(2, attempt) * 1000);\n          continue;\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  private handleError(error: any): WaitlyError {\n    if (error.statusCode === 400) {\n      return {\n        code: \"VALIDATION_ERROR\",\n        message: error.message || \"Invalid request data\",\n        details: error.details,\n        statusCode: 400,\n      };\n    }\n\n    if (error.statusCode === 401) {\n      return {\n        code: \"UNAUTHORIZED\",\n        message: \"Invalid API key\",\n        statusCode: 401,\n      };\n    }\n\n    if (error.statusCode === 404) {\n      return {\n        code: \"NOT_FOUND\",\n        message: \"Waitlist not found\",\n        statusCode: 404,\n      };\n    }\n\n    if (error.statusCode === 409) {\n      return {\n        code: \"DUPLICATE_ENTRY\",\n        message: error.message || \"Email already registered\",\n        statusCode: 409,\n      };\n    }\n\n    if (error.statusCode === 429) {\n      return {\n        code: \"RATE_LIMIT\",\n        message: \"Too many requests\",\n        statusCode: 429,\n      };\n    }\n\n    if (error.message === \"Request timeout\") {\n      return {\n        code: \"TIMEOUT\",\n        message: \"Request timeout\",\n        statusCode: 0,\n      };\n    }\n\n    return {\n      code: \"UNKNOWN_ERROR\",\n      message: error.message || \"An unexpected error occurred\",\n      details: error,\n      statusCode: error.statusCode || 0,\n    };\n  }\n\n  private isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\nexport function createWaitlyClient(config: WaitlyConfig): WaitlyClient {\n  return new WaitlyClient(config);\n}\n\nexport default { createWaitlyClient, WaitlyClient };\n"]}